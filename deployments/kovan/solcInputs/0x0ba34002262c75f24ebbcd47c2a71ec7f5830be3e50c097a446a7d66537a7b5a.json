{
  "language": "Solidity",
  "sources": {
    "contracts/core/ENSGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"@ensdomains/ens/contracts/ENS.sol\";\nimport \"@ensdomains/resolver/contracts/Resolver.sol\";\n\nimport \"./mixins/Initializable.sol\";\nimport \"./mixins/Ownable.sol\";\nimport \"./interfaces/IENSGateway.sol\";\nimport \"./interfaces/IENSReverseRegistrar.sol\";\n\ncontract ENSGateway is Initializable, Ownable, IENSGateway {\n    address private _resolver;\n\n    function initialize(address owner) public initializer {\n        _initialize(owner);\n        _resolver = ENS(ens()).resolver(tldNode());\n        require(_resolver != address(0), \"resolver-not-set\");\n    }\n\n    function setTLDOwner(address newOwner) public onlyOwner {\n        ENS(ens()).setOwner(tldNode(), newOwner);\n    }\n\n    function ens() public override view returns (address) {\n        return 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e;\n    }\n\n    function resolver() public override view returns (address) {\n        return _resolver;\n    }\n\n    function tld() public override view returns (string memory) {\n        return \"levx.eth\";\n    }\n\n    // namehash(\"levx.eth\")\n    function tldNode() public override view returns (bytes32) {\n        return 0xf88903d82aebfe9a5fa03a1a6eb4475330ed9991c9b6ffea0f6d0154a210efbe;\n    }\n\n    function subdomainNode(bytes32 label) public override view returns (bytes32) {\n        return keccak256(abi.encodePacked(tldNode(), label));\n    }\n\n    function ownerOfSubdomain(bytes32 label) public override view returns (address) {\n        return ENS(ens()).owner(subdomainNode(label));\n    }\n\n    function resolverOfSubdomain(bytes32 label) public override view returns (address) {\n        return ENS(ens()).resolver(subdomainNode(label));\n    }\n\n    function registerSubdomain(bytes32 label, address addr) public override {\n        require(label != bytes32(0), \"invalid-label\");\n        require(addr != address(0), \"invalid-addr\");\n        require(ownerOfSubdomain(label) == address(0), \"already-registered\");\n\n        ENS(ens()).setSubnodeRecord(tldNode(), label, address(this), _resolver, 0);\n        Resolver(_resolver).setAddr(subdomainNode(label), addr);\n\n        ENS(ens()).setSubnodeOwner(tldNode(), label, msg.sender);\n\n        emit SubdomainRegistered(label, msg.sender, addr);\n    }\n}\n"
    },
    "@ensdomains/ens/contracts/ENS.sol": {
      "content": "pragma solidity >=0.4.24;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n    function recordExists(bytes32 node) external view returns (bool);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@ensdomains/resolver/contracts/Resolver.sol": {
      "content": "pragma solidity >=0.4.25;\npragma experimental ABIEncoderV2;\n\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver{\n    event AddrChanged(bytes32 indexed node, address a);\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\n    event NameChanged(bytes32 indexed node, string name);\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\n    function addr(bytes32 node) external view returns (address);\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\n    function contenthash(bytes32 node) external view returns (bytes memory);\n    function dnsrr(bytes32 node) external view returns (bytes memory);\n    function name(bytes32 node) external view returns (string memory);\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n    function setAddr(bytes32 node, address addr) external;\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n    function setName(bytes32 node, string calldata _name) external;\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n    function multihash(bytes32 node) external view returns (bytes memory);\n    function setContent(bytes32 node, bytes32 hash) external;\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n"
    },
    "contracts/core/mixins/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// https://github.com/OpenZeppelin/openzeppelin-sdk/blob/master/packages/lib/contracts/Initializable.sol\n\npragma solidity ^0.6.8;\n\ncontract Initializable {\n    bool public initialized;\n\n    bool private initializing;\n\n    modifier initializer() {\n        require(initializing || !initialized, \"already-initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/core/mixins/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n\npragma solidity ^0.6.8;\n\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner {\n        require(_owner == msg.sender, \"msg-sender-not-owner\");\n        _;\n    }\n\n    function _initialize(address owner) internal {\n        _owner = owner;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"invalid-address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n}\n"
    },
    "contracts/core/interfaces/IENSGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IENSGateway {\n    event SubdomainRegistered(bytes32 indexed label, address owner, address addr);\n\n    function ens() external view returns (address);\n\n    function resolver() external view returns (address);\n\n    function tld() external view returns (string memory);\n\n    function tldNode() external view returns (bytes32);\n\n    function subdomainNode(bytes32 label) external view returns (bytes32);\n\n    function ownerOfSubdomain(bytes32 label) external view returns (address);\n\n    function resolverOfSubdomain(bytes32 label) external view returns (address);\n\n    function registerSubdomain(bytes32 label, address addr) external;\n}\n"
    },
    "contracts/core/interfaces/IENSReverseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IENSReverseRegistrar {\n    function ens() external view returns (address);\n\n    function defaultResolver() external view returns (address);\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimWithResolver(address owner, address resolver) external returns (bytes32);\n\n    function setName(string calldata name) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}\n"
    },
    "contracts/core/interfaces/IETHPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IETHPriceFeed {\n    function ethPriceInUSD() external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IMakerPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IMakerPriceFeed {\n    function read() external view returns (bytes32);\n}\n"
    },
    "contracts/core/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IPriceFeed {\n    function ethPriceInUSD(uint256 amount) external view returns (uint256);\n\n    function erc20PriceInETH(address token, uint256 amount) external view returns (uint256);\n\n    function erc20PriceInUSD(address token, uint256 amount) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/ITXRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface ITXRelayer {\n    event Relayed(address indexed target, bytes data);\n    event FeeCollected(address feeToken, uint256 amount);\n\n    function freeExecutionResetPeriod() external pure returns (uint256);\n\n    function freeExecutionMax() external pure returns (uint256);\n\n    function freeExecutionLeft(address addr) external view returns (uint256);\n\n    function relay(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        address feeToken\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/core/interfaces/IWalletRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IWalletRegistry {\n    function versionNames() external returns (bytes32[] memory);\n\n    function register(bytes32 versionName, address addr) external;\n\n    function latest() external view returns (bytes32 versionName, address addr);\n\n    function queryWithAddress(address addr) external view returns (bytes32 versionName);\n\n    function queryWithVersionName(bytes32 versionName) external view returns (address add);\n}\n"
    },
    "contracts/core/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// solhint-disable-next-line max-line-length\n// UniswapV2Library https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"identical-addresses\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"zero-address\");\n    }\n\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\"\n                        // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        address pair = pairFor(factory, tokenA, tokenB);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = pair.staticcall(\n            abi.encodeWithSignature(\"getReserves()\") // IUniswapV2Pair.getReserves()\n        );\n        if (success) {\n            (uint112 reserve0, uint112 reserve1, ) = abi.decode(data, (uint112, uint112, uint32));\n            (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        } else {\n            // Pair doesn't exist so cannot call 'getReserves()'\n            return (0, 0);\n        }\n    }\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"insufficient-amount\");\n        require(reserveA > 0 && reserveB > 0, \"insufficient-liquidity\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"insufficient-input-amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient-liquidity\");\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"insufficient-output-amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient-liquidity\");\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/core/mocks/AddrResolverMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\ncontract AddrResolverMock {\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    address private _owner;\n    mapping(bytes32 => mapping(uint256 => bytes)) private _addresses;\n\n    event AddrChanged(bytes32 indexed node, address a);\n    event AddressChanged(bytes32 indexed node, uint256 coinType, bytes newAddress);\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function isAuthorised() internal view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    modifier authorised() {\n        require(isAuthorised(), \"not-authorised\");\n        _;\n    }\n\n    function setAddr(bytes32 node, address a) public authorised {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    function addr(bytes32 node) public view returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if (a.length == 0) {\n            return address(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function setAddr(\n        bytes32 node,\n        uint256 coinType,\n        bytes memory a\n    ) public authorised {\n        emit AddressChanged(node, coinType, a);\n        if (coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, bytesToAddress(a));\n        }\n        _addresses[node][coinType] = a;\n    }\n\n    function addr(bytes32 node, uint256 coinType) public view returns (bytes memory) {\n        return _addresses[node][coinType];\n    }\n\n    function bytesToAddress(bytes memory b) internal pure returns (address payable a) {\n        require(b.length == 20, \"\");\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "contracts/core/mocks/ENSGatewayMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"../mixins/Initializable.sol\";\nimport \"../interfaces/IENSGateway.sol\";\nimport \"./AddrResolverMock.sol\";\n\ncontract ENSGatewayMock is Initializable, IENSGateway {\n    mapping(bytes32 => address) internal _owners;\n    AddrResolverMock internal _resolver;\n\n    function initialize(address) public initializer {\n        _resolver = new AddrResolverMock();\n    }\n\n    function ens() public override view returns (address) {\n        return 0x0000000000000000000000000000000000000000;\n    }\n\n    function resolver() public override view returns (address) {\n        return 0x0000000000000000000000000000000000000000;\n    }\n\n    function tld() public override view returns (string memory) {\n        return \"levx.eth\";\n    }\n\n    // namehash(\"levx.eth\")\n    function tldNode() public override view returns (bytes32) {\n        return 0xf88903d82aebfe9a5fa03a1a6eb4475330ed9991c9b6ffea0f6d0154a210efbe;\n    }\n\n    function subdomainNode(bytes32 label) public override view returns (bytes32) {\n        return keccak256(abi.encodePacked(tldNode(), label));\n    }\n\n    function ownerOfSubdomain(bytes32 label) public override view returns (address) {\n        return _owners[label];\n    }\n\n    function resolverOfSubdomain(bytes32) public override view returns (address) {\n        return address(_resolver);\n    }\n\n    function registerSubdomain(bytes32 label, address addr) public override {\n        require(label != bytes32(0), \"invalid-label\");\n        require(addr != address(0), \"invalid-addr\");\n        require(ownerOfSubdomain(label) == address(0), \"already-registered\");\n\n        _owners[label] = msg.sender;\n        _resolver.setAddr(subdomainNode(label), addr);\n    }\n}\n"
    },
    "contracts/core/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ERC20Mock is ERC20, Ownable {\n    constructor() public ERC20(\"E2M\", \"ERC20Mock\") {\n        _setupDecimals(8);\n        _mint(msg.sender, 21000000 * 10**8);\n    }\n\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/core/mocks/MakerPriceFeedMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"../interfaces/IMakerPriceFeed.sol\";\n\ncontract MakerPriceFeedMock is IMakerPriceFeed {\n    function read() public override view returns (bytes32) {\n        return bytes32(uint256(10**20)); // 100 USD\n    }\n}\n"
    },
    "contracts/core/mocks/PriceFeedMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/IPriceFeed.sol\";\n\ncontract PriceFeedMock is IPriceFeed {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line no-empty-blocks\n    function initialize(address) public {}\n\n    function ethPriceInUSD(uint256 amount) public override view returns (uint256) {\n        return amount.mul(100 * 10**18).div(10**18); // 100$ per 1ETH\n    }\n\n    function erc20PriceInETH(address token, uint256 amount) public override view returns (uint256) {\n        uint256 decimals = ERC20(token).decimals();\n        return amount.mul(10**16).div(10**decimals); // 0.01ETH per 1ERC20\n    }\n\n    function erc20PriceInUSD(address token, uint256 amount) public override view returns (uint256) {\n        uint256 decimals = ERC20(token).decimals();\n        return amount.mul(10**18).div(10**decimals); // 1$ per 1ERC20\n    }\n}\n"
    },
    "contracts/core/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\nimport \"./mixins/Initializable.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./interfaces/IMakerPriceFeed.sol\";\nimport \"./libraries/UniswapV2Library.sol\";\n\ncontract PriceFeed is Initializable, IPriceFeed {\n    using SafeMath for uint256;\n\n    address internal _uniswapFactory;\n    address internal _weth;\n    address internal _makerPriceFeed;\n\n    function initialize(address makerPriceFeed) public initializer {\n        _makerPriceFeed = makerPriceFeed;\n\n        IUniswapV2Router02 router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        _uniswapFactory = router.factory();\n        _weth = router.WETH();\n    }\n\n    function ethPriceInUSD(uint256 amount) public override view returns (uint256) {\n        uint256 price = uint256(IMakerPriceFeed(_makerPriceFeed).read());\n        return price.mul(amount).div(10**18);\n    }\n\n    function erc20PriceInETH(address token, uint256 amount) public override view returns (uint256) {\n        (uint256 reserve0, uint256 reserve1) = UniswapV2Library.getReserves(\n            _uniswapFactory,\n            token,\n            _weth\n        );\n        if (reserve0 > 0 && reserve1 > 0) {\n            return UniswapV2Library.quote(amount, reserve0, reserve1);\n        }\n        return 0;\n    }\n\n    function erc20PriceInUSD(address token, uint256 amount) public override view returns (uint256) {\n        uint256 ethPrice = ethPriceInUSD(10**18);\n        uint256 erc20Price = erc20PriceInETH(token, amount);\n        return erc20Price == 0 ? 0 : ethPrice.mul(erc20Price).div(10**18);\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/core/WalletRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"./mixins/Initializable.sol\";\nimport \"./mixins/Ownable.sol\";\nimport \"./interfaces/IWalletRegistry.sol\";\n\ncontract WalletRegistry is Initializable, Ownable, IWalletRegistry {\n    struct Implementation {\n        bytes32 versionName;\n        address addr;\n    }\n\n    Implementation[] internal _wallets;\n\n    function initialize(address owner) public initializer {\n        _initialize(owner);\n    }\n\n    function versionNames() public override returns (bytes32[] memory) {\n        bytes32[] memory v = new bytes32[](_wallets.length);\n        for (uint256 i = 0; i < _wallets.length; i++) {\n            v[i] = _wallets[i].versionName;\n        }\n        return v;\n    }\n\n    function register(bytes32 versionName, address addr) public override onlyOwner {\n        require(versionName != bytes32(0), \"version-must-not-be-empty\");\n        require(addr != address(0), \"address-must-not-be-zero\");\n\n        Implementation storage wallet = _wallets.push();\n        wallet.versionName = versionName;\n        wallet.addr = addr;\n    }\n\n    function latest() public override view returns (bytes32 versionName, address addr) {\n        uint256 length = _wallets.length;\n        if (length > 0) {\n            Implementation storage wallet = _wallets[length - 1];\n            return (wallet.versionName, wallet.addr);\n        } else {\n            return (0, address(0));\n        }\n    }\n\n    function queryWithAddress(address addr) public override view returns (bytes32 versionName) {\n        for (uint256 i = 0; i < _wallets.length; i++) {\n            Implementation storage wallet = _wallets[i];\n            if (wallet.addr == addr) {\n                return wallet.versionName;\n            }\n        }\n        return 0;\n    }\n\n    function queryWithVersionName(bytes32 versionName) public override view returns (address add) {\n        for (uint256 i = 0; i < _wallets.length; i++) {\n            Implementation storage wallet = _wallets[i];\n            if (wallet.versionName == versionName) {\n                return wallet.addr;\n            }\n        }\n        return address(0);\n    }\n}\n"
    },
    "contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\n/**\n * @notice Implements https://eips.ethereum.org/EIPS/eip-1822\n * EIP-1822: Universal Upgradeable Proxy Standard (UUPS)\n */\ncontract Proxy {\n    event ETHReceived(address indexed sender, uint256 indexed value);\n\n    // keccak256(\"PROXIABLE\") = 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\n    bytes32\n        private constant UUID = 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\n\n    constructor(address implementation) public {\n        assembly {\n            sstore(UUID, implementation)\n        }\n    }\n\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    fallback() external payable {\n        assembly {\n            let impl := sload(UUID)\n            calldatacopy(0x0, 0x0, calldatasize())\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n}\n"
    },
    "contracts/proxy/ProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\nimport \"./Proxy.sol\";\n\ncontract ProxyFactory {\n    using ECDSA for bytes32;\n\n    mapping(address => bool) private _proxies;\n\n    event ProxyCreated(address indexed implementation, address proxy);\n\n    function isProxy(address addr) public view returns (bool) {\n        return _proxies[addr];\n    }\n\n    function createProxy(\n        address implementation,\n        bytes32 salt,\n        bytes memory initializeData,\n        bytes memory signature\n    ) public returns (address payable addr) {\n        require(_proxies[addr] == false, \"proxy-already-created\");\n        _proxies[addr] = true;\n\n        address signer = createProxyHash(implementation, salt, initializeData)\n            .toEthSignedMessageHash()\n            .recover(signature);\n        bytes32 signerSalt = keccak256(abi.encodePacked(signer, salt));\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, abi.encode(implementation));\n        assembly {\n            addr := create2(0, add(code, 0x20), mload(code), signerSalt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = addr.call(initializeData);\n        require(success, \"failed-to-initialize\");\n\n        emit ProxyCreated(implementation, addr);\n    }\n\n    function createProxyHash(\n        address implementation,\n        bytes32 salt,\n        bytes memory initializeData\n    ) public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    this.createProxy.selector,\n                    implementation,\n                    salt,\n                    initializeData\n                )\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/wallet/interfaces/IWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../mixins/interfaces/IBaseMixin.sol\";\nimport \"../mixins/interfaces/IAuthorizable.sol\";\nimport \"../mixins/interfaces/IUpgradeable.sol\";\nimport \"../mixins/interfaces/ILockable.sol\";\nimport \"../mixins/interfaces/ITransferable.sol\";\nimport \"../mixins/interfaces/IExecutable.sol\";\nimport \"../../core/interfaces/IENSGateway.sol\";\n\ninterface IWallet is\n    IBaseMixin,\n    IAuthorizable,\n    IUpgradeable,\n    ILockable,\n    ITransferable,\n    IExecutable\n{\n    function initialize(\n        IENSGateway ensGateway,\n        bytes32 label,\n        address owner,\n        address[] calldata witnessAddrs,\n        bytes32[] calldata witnessNames\n    ) external;\n}\n"
    },
    "contracts/wallet/mixins/interfaces/IBaseMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/Storage.sol\";\n\ninterface IBaseMixin {\n    event Initialized();\n    event Spent(uint256 valueInUSD, uint256 timestamp);\n\n    function initialized() external view returns (bool);\n\n    function label() external view returns (bytes32);\n\n    function nonce() external view returns (uint256);\n\n    function signingRequirements(bytes4 methodId)\n        external\n        view\n        returns (Storage.SigningRequirements memory);\n\n    function securityPeriod(bytes4 methodId) external view returns (Storage.SecurityPeriod memory);\n\n    function lastExecutionTime(bytes4 selector) external view returns (uint256);\n\n    function resolveENS(bytes32 subdomain) external view returns (address);\n\n    function isValidSignature(bytes32 hash, bytes calldata signature)\n        external\n        view\n        returns (bytes4);\n\n    function isValidOwnerSignature(bytes32 hash, bytes calldata signature)\n        external\n        view\n        returns (bool);\n\n    function areValidWitnessSignatures(bytes32 hash, bytes[] calldata signatures)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/wallet/libraries/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nlibrary Storage {\n    using ECDSA for bytes32;\n    using Address for address;\n\n    uint256 private constant MINIMUM_TRANSFER_LIMIT_IN_USD = 10**20; // 100 USD\n    uint256 private constant TRANSFER_CAPACITY_RESET_PERIOD = 24 hours;\n\n    struct Signatures {\n        bytes owner;\n        bytes[] witnesses;\n    }\n\n    struct SigningRequirements {\n        bool owner;\n        uint256 witnesses;\n    }\n\n    struct SecurityPeriod {\n        uint256 time;\n        bytes4[] dependencies;\n    }\n\n    struct Spending {\n        uint256 valueInUSD;\n        uint256 timestamp;\n    }\n\n    struct Data {\n        uint256 _nonce;\n        mapping(bytes4 => SigningRequirements) _signingRequirements;\n        mapping(bytes4 => SecurityPeriod) _securityPeriods;\n        mapping(bytes4 => uint256) _lastExecutionTime;\n        bytes32 _label;\n        address _owner;\n        mapping(address => bytes32) _witnessNames;\n        address[] _witnesses;\n        bool _locked;\n        Spending[] _spending;\n    }\n\n    function label(Data storage self) public view returns (bytes32) {\n        return self._label;\n    }\n\n    function setLabel(Data storage self, bytes32 label_) public {\n        self._label = label_;\n    }\n\n    function nonce(Data storage self) public view returns (uint256) {\n        return self._nonce;\n    }\n\n    function incrementNonce(Data storage self) public {\n        self._nonce += 1;\n    }\n\n    function signingRequirements(Data storage self, bytes4 methodId)\n        public\n        view\n        returns (SigningRequirements storage)\n    {\n        return self._signingRequirements[methodId];\n    }\n\n    function setSigningRequirements(\n        Data storage self,\n        bytes4 methodId,\n        bool ownerRequired,\n        uint256 witnessesRequired\n    ) public {\n        self._signingRequirements[methodId].owner = ownerRequired;\n        self._signingRequirements[methodId].witnesses = witnessesRequired;\n    }\n\n    function securityPeriod(Data storage self, bytes4 methodId)\n        public\n        view\n        returns (SecurityPeriod storage)\n    {\n        return self._securityPeriods[methodId];\n    }\n\n    function setSecurityPeriod(\n        Data storage self,\n        bytes4 methodId,\n        uint256 time,\n        bytes4[] memory dependencies\n    ) public {\n        self._securityPeriods[methodId].time = time;\n        self._securityPeriods[methodId].dependencies = dependencies;\n    }\n\n    /**\n     * @notice Last executed timestamp that the method of 'selector' called\n     */\n    function lastExecutionTime(Data storage self, bytes4 selector) public view returns (uint256) {\n        return self._lastExecutionTime[selector];\n    }\n\n    function updateLastExecutionTime(Data storage self, bytes4 selector) public {\n        self._lastExecutionTime[selector] = now;\n    }\n\n    /**\n     * @notice The owner\n     */\n    function owner(Data storage self) public view returns (address) {\n        return self._owner;\n    }\n\n    function transferOwnership(Data storage self, address newOwner) public {\n        require(newOwner != address(0), \"invalid-owner\");\n        require(newOwner != address(this), \"wallet-cannot-be-owner\");\n        require(self._witnessNames[newOwner] == bytes32(0), \"witness-cannot-be-owner\");\n        address previousOwner = self._owner;\n        require(previousOwner != newOwner, \"already-owner\");\n        self._owner = newOwner;\n    }\n\n    /**\n     * @notice Witness names for their addresses\n     */\n    function witnessNames(Data storage self, address addr) public view returns (bytes32) {\n        return self._witnessNames[addr];\n    }\n\n    /**\n     * @notice Witness addresses\n     */\n    function witnesses(Data storage self, uint256 index) public view returns (address) {\n        return self._witnesses[index];\n    }\n\n    function numberOfWitnesses(Data storage self) public view returns (uint256) {\n        return self._witnesses.length;\n    }\n\n    function addWitness(\n        Data storage self,\n        address addr,\n        bytes32 name\n    ) public {\n        require(addr != address(0), \"invalid-address\");\n        require(name != bytes32(0), \"invalid-name\");\n        require(addr != address(this), \"cannot-add-wallet\");\n        require(self._owner != addr, \"cannot-add-owner\");\n        require(self._witnessNames[addr] == bytes32(0), \"witness-exists\");\n\n        self._witnessNames[addr] = name;\n        self._witnesses.push(addr);\n    }\n\n    function removeWitness(Data storage self, address addr) public {\n        require(addr != address(0), \"invalid-address\");\n        require(self._witnesses.length > 1, \"at-least-one-witness-required\");\n        require(self._witnessNames[addr] != bytes32(0), \"not-witness\");\n\n        delete self._witnessNames[addr];\n        for (uint256 i = 0; i < self._witnesses.length; i++) {\n            if (self._witnesses[i] == addr) {\n                self._witnesses[i] = self._witnesses[self._witnesses.length - 1];\n                self._witnesses.pop();\n                break;\n            }\n        }\n    }\n\n    function locked(Data storage self) public view returns (bool) {\n        return self._locked;\n    }\n\n    function setLocked(Data storage self, bool newLocked) public {\n        self._locked = newLocked;\n    }\n\n    /**\n     * @notice How much an owner can spend with 0 witness\n     *\n     * For each signature of a witness is offered, limit is multiplied by 10\n     */\n    function minimumTransferLimitInUSD(Data storage) public pure returns (uint256) {\n        return MINIMUM_TRANSFER_LIMIT_IN_USD;\n    }\n\n    function transferCapacityResetPeriod(Data storage) public pure returns (uint256) {\n        return TRANSFER_CAPACITY_RESET_PERIOD;\n    }\n\n    /**\n     * @notice Transfer capacity available in USD\n     *\n     * 10**18 = 1 USD\n     */\n    function transferCapacityInUSD(Data storage self, uint256 numberOfWitnessSignatures)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 limitInUSD = MINIMUM_TRANSFER_LIMIT_IN_USD * (10**numberOfWitnessSignatures);\n        uint256 spendingInUSD = cumulativeSpendingInUSD(self, now - TRANSFER_CAPACITY_RESET_PERIOD);\n        return limitInUSD > spendingInUSD ? limitInUSD - spendingInUSD : 0;\n    }\n\n    /**\n     * @notice Cumulative value spent in USD after 'fromTimestamp'\n     g\n     */\n    function cumulativeSpendingInUSD(Data storage self, uint256 fromTimestamp)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 spending = 0;\n        if (self._spending.length > 0) {\n            for (uint256 i = self._spending.length; i > 0; i--) {\n                Spending storage spent = self._spending[i - 1];\n                if (spent.timestamp < fromTimestamp) {\n                    break;\n                }\n                spending += spent.valueInUSD;\n            }\n        }\n        return spending;\n    }\n\n    function addSpending(Data storage self, uint256 valueInUSD) public {\n        Spending storage spent = self._spending.push();\n        spent.valueInUSD = valueInUSD;\n        spent.timestamp = now;\n    }\n\n    function isValidOwnerSignature(\n        Data storage self,\n        bytes32 hash,\n        bytes memory signature\n    ) public view returns (bool) {\n        return _verify(hash, self._owner, signature);\n    }\n\n    function areValidWitnessSignatures(\n        Data storage self,\n        bytes32 hash,\n        bytes[] memory signatures\n    ) public view returns (bool) {\n        if (_duplicate(signatures)) {\n            return false;\n        }\n        for (uint256 i = 0; i < signatures.length; i++) {\n            bytes memory signature = signatures[i];\n            bool valid = false;\n            for (uint256 j = 0; j < self._witnesses.length; j++) {\n                if (_verify(hash, self._witnesses[j], signature)) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @return true if array has duplicate items, false otherwise\n     */\n    function _duplicate(bytes[] memory array) private pure returns (bool) {\n        bytes32[] memory hashes = new bytes32[](array.length);\n        for (uint256 i = 0; i < array.length; i++) {\n            hashes[i] = keccak256(array[i]);\n        }\n        for (uint256 i = 0; i < hashes.length; i++) {\n            for (uint256 j = i + 1; j < hashes.length; j++) {\n                if (hashes[i] == hashes[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function _verify(\n        bytes32 hash,\n        address signer,\n        bytes memory signature\n    ) public view returns (bool) {\n        if (signer.isContract()) {\n            // Consider the signer as an EIP-1271 compatible contract\n            // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")) = 0x1626ba7e\n            bytes4 magicValue = 0x1626ba7e;\n            (bool success, bytes memory data) = signer.staticcall(abi.encodePacked(magicValue));\n            if (success) {\n                bytes4 returned = abi.decode(data, (bytes4));\n                return magicValue == returned;\n            } else {\n                return false;\n            }\n        } else {\n            // Try EIP-712\n            bool v = signer == hash.recover(signature);\n            if (v) {\n                return true;\n            } else {\n                // Consider signed by web3.eth_sign\n                hash = hash.toEthSignedMessageHash();\n                return signer == hash.recover(signature);\n            }\n        }\n    }\n}\n"
    },
    "contracts/wallet/mixins/interfaces/IAuthorizable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/Storage.sol\";\n\ninterface IAuthorizable {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event WitnessAdded(address indexed addr, bytes32 name);\n    event WitnessRemoved(address indexed addr);\n\n    function owner() external view returns (address);\n\n    function witnessNames(address addr) external view returns (bytes32);\n\n    function witnesses(uint256 index) external view returns (address);\n\n    function numberOfWitnesses() external view returns (uint256);\n\n    function transferOwnership(address newOwner, Storage.Signatures calldata signatures) external;\n\n    function transferOwnershipHash(address newOwner) external view returns (bytes32);\n\n    function addWitness(\n        address ownerAddr,\n        bytes32 ownerName,\n        Storage.Signatures calldata signatures\n    ) external;\n\n    function addWitnessHash(address ownerAddr, bytes32 ownerName) external view returns (bytes32);\n\n    function removeWitness(address ownerAddr, Storage.Signatures calldata signatures) external;\n\n    function removeWitnessHash(address ownerAddr) external view returns (bytes32);\n}\n"
    },
    "contracts/wallet/mixins/interfaces/IUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/Storage.sol\";\n\ninterface IUpgradeable {\n    event Upgraded(address implementation);\n\n    function proxiableUUID() external pure returns (bytes32);\n\n    function implementation() external view returns (address addr);\n\n    function upgrade(address impl, Storage.Signatures calldata) external;\n\n    function upgradeHash(address impl) external view returns (bytes32);\n}\n"
    },
    "contracts/wallet/mixins/interfaces/ILockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/Storage.sol\";\n\ninterface ILockable {\n    event Locked();\n    event Unlocked();\n\n    function locked() external view returns (bool);\n\n    function lock(Storage.Signatures calldata signatures) external;\n\n    function lockHash() external view returns (bytes32);\n\n    function unlock(Storage.Signatures calldata signatures) external;\n\n    function unlockHash() external view returns (bytes32);\n}\n"
    },
    "contracts/wallet/mixins/interfaces/ITransferable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/Storage.sol\";\n\ninterface ITransferable {\n    event ETHTransferred(address indexed to, uint256 indexed value);\n\n    function minimumTransferLimitInUSD() external view returns (uint256);\n\n    function transferCapacityResetPeriod() external view returns (uint256);\n\n    function transferCapacityInUSD(uint256 numberOfWitnessSignatures)\n        external\n        view\n        returns (uint256);\n\n    function cumulativeSpendingInUSD(uint256 fromTimestamp) external view returns (uint256);\n\n    function transferETH(\n        address payable to,\n        uint256 value,\n        Storage.Signatures calldata signatures\n    ) external;\n\n    function transferETHHash(address payable to, uint256 value) external view returns (bytes32);\n\n    function transferERC20(\n        address token,\n        address to,\n        uint256 value,\n        Storage.Signatures calldata signatures\n    ) external;\n\n    function transferERC20Hash(\n        address token,\n        address to,\n        uint256 value\n    ) external view returns (bytes32);\n}\n"
    },
    "contracts/wallet/mixins/interfaces/IExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/Storage.sol\";\n\ninterface IExecutable {\n    event Executed(address indexed target, uint256 value, bytes data);\n\n    function execute(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata data,\n        Storage.Signatures calldata signatures\n    ) external payable returns (bytes[] memory);\n\n    function executeHash(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata data\n    ) external view returns (bytes32);\n}\n"
    },
    "contracts/wallet/mixins/Authorizable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseMixin.sol\";\nimport \"./interfaces/IAuthorizable.sol\";\n\n/**\n * @notice Implements https://eips.ethereum.org/EIPS/eip-173\n * EIP-173: Contract Ownership Standard\n */\nabstract contract Authorizable is BaseMixin, IAuthorizable {\n    function _initialize() internal virtual {\n        _storage.setSigningRequirements(\n            this.transferOwnership.selector,\n            false,\n            ((_storage.numberOfWitnesses() + 1) * 2) / 3\n        );\n        _storage.setSigningRequirements(this.addWitness.selector, true, 0);\n        _storage.setSigningRequirements(this.removeWitness.selector, true, 0);\n\n        _storage.setSecurityPeriod(this.transferOwnership.selector, 0, new bytes4[](0));\n        bytes4[] memory dependencies = new bytes4[](3);\n        dependencies[0] = this.transferOwnership.selector;\n        dependencies[1] = this.addWitness.selector;\n        dependencies[2] = this.removeWitness.selector;\n        _storage.setSecurityPeriod(this.addWitness.selector, 24 hours, dependencies);\n        _storage.setSecurityPeriod(this.removeWitness.selector, 24 hours, dependencies);\n    }\n\n    function owner() public override view returns (address) {\n        return _storage.owner();\n    }\n\n    function witnessNames(address addr) public override view returns (bytes32) {\n        return _storage.witnessNames(addr);\n    }\n\n    function witnesses(uint256 index) public override view returns (address) {\n        return _storage.witnesses(index);\n    }\n\n    function numberOfWitnesses() public override view returns (uint256) {\n        return _storage.numberOfWitnesses();\n    }\n\n    /**\n     * @notice Transfers the ownership to a new owner\n     *\n     * Signatures of '((n + 1) * 2) / 3' required where 'n' is the number of the witnesses\n     */\n    function transferOwnership(address newOwner, Storage.Signatures memory signatures)\n        public\n        override\n        whenInitialized\n    {\n        _ensureSecurityPeriodPassed(this.transferOwnership.selector);\n        _ensureSignaturesValid(\n            this.transferOwnership.selector,\n            transferOwnershipHash(newOwner),\n            signatures\n        );\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.transferOwnership.selector);\n\n        address previousOwner = _storage.owner();\n        _storage.transferOwnership(newOwner);\n\n        emit OwnershipTransferred(previousOwner, newOwner);\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'transferOwnership()'\n     */\n    function transferOwnershipHash(address newOwner) public override view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.transferOwnership.selector,\n                    newOwner\n                )\n            );\n    }\n\n    /**\n     * @notice Adds a new owner\n     *\n     * Signatures of the owner needed\n     */\n    function addWitness(\n        address addr,\n        bytes32 name,\n        Storage.Signatures memory signatures\n    ) public override whenInitialized whenNotLocked {\n        _ensureSecurityPeriodPassed(this.addWitness.selector);\n        _ensureSignaturesValid(this.addWitness.selector, addWitnessHash(addr, name), signatures);\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.addWitness.selector);\n        _storage.addWitness(addr, name);\n\n        emit WitnessAdded(addr, name);\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'addWitness()'\n     */\n    function addWitnessHash(address addr, bytes32 name) public override view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.addWitness.selector,\n                    addr,\n                    name\n                )\n            );\n    }\n\n    /**\n     * @notice Removes an existing owner\n     *\n     * Signature of the owner needed\n     */\n    function removeWitness(address addr, Storage.Signatures memory signatures)\n        public\n        override\n        whenInitialized\n        whenNotLocked\n    {\n        _ensureSecurityPeriodPassed(this.removeWitness.selector);\n        _ensureSignaturesValid(this.removeWitness.selector, removeWitnessHash(addr), signatures);\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.removeWitness.selector);\n        _storage.removeWitness(addr);\n\n        emit WitnessRemoved(addr);\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'removeWitness()'\n     */\n    function removeWitnessHash(address addr) public override view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.removeWitness.selector,\n                    addr\n                )\n            );\n    }\n}\n"
    },
    "contracts/wallet/mixins/BaseMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@ensdomains/resolver/contracts/Resolver.sol\";\n\nimport \"./interfaces/IBaseMixin.sol\";\nimport \"../../core/interfaces/IENSGateway.sol\";\nimport \"../../core/interfaces/IPriceFeed.sol\";\n\n/**\n * @notice Implements https://eips.ethereum.org/EIPS/eip-1271\n * EIP-1271: Standard Signature Validation Method for Contracts\n */\nabstract contract BaseMixin is IBaseMixin {\n    using Storage for Storage.Data;\n\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    bool private _initialized;\n    bool private _initializing;\n    uint256 private _status;\n    IENSGateway private _ensGateway;\n    Storage.Data internal _storage;\n\n    modifier whenInitialized {\n        require(_initialized, \"not-initialized\");\n        _;\n    }\n\n    modifier initializer() {\n        require(_initializing || !_initialized, \"already-initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n\n        emit Initialized();\n    }\n\n    modifier nonReentrant {\n        require(_status != ENTERED, \"reentrant-call\");\n\n        _status = ENTERED;\n        _;\n        _status = NOT_ENTERED;\n    }\n\n    modifier whenLocked {\n        require(_storage.locked(), \"not-locked\");\n        _;\n    }\n\n    modifier whenNotLocked {\n        require(!_storage.locked(), \"already-locked\");\n        _;\n    }\n\n    function _initialize(IENSGateway ensGateway, bytes32 label) internal {\n        require(address(ensGateway) != address(0), \"invalid-ens-gateway\");\n        require(label != bytes32(0), \"invalid-label\");\n\n        _status = NOT_ENTERED;\n        _ensGateway = ensGateway;\n        _ensGateway.registerSubdomain(label, address(this));\n        _storage.setLabel(label);\n    }\n\n    function _ensureSignaturesValid(\n        bytes4 methodId,\n        bytes32 hash,\n        Storage.Signatures memory signatures\n    ) internal view {\n        Storage.SigningRequirements storage requirements = _storage.signingRequirements(methodId);\n        if (requirements.owner) {\n            require(_storage.isValidOwnerSignature(hash, signatures.owner), \"not-signed-by-owner\");\n        }\n        require(signatures.witnesses.length >= requirements.witnesses, \"more-signatures-required\");\n        require(\n            _storage.areValidWitnessSignatures(hash, signatures.witnesses),\n            \"not-signed-by-witnesses\"\n        );\n    }\n\n    function _ensureSecurityPeriodPassed(bytes4 methodId) internal view {\n        Storage.SecurityPeriod storage period = _storage.securityPeriod(methodId);\n        for (uint256 i = 0; i < period.dependencies.length; i++) {\n            require(\n                now > _storage.lastExecutionTime(period.dependencies[i]) + period.time,\n                \"security-period-not-passed\"\n            );\n        }\n    }\n\n    function _addETHSpending(uint256 value, uint256 numberOfWitnessSignatures) internal {\n        uint256 valueInUSD = _priceFeed().ethPriceInUSD(value);\n        uint256 limitInUSD = _storage.transferCapacityInUSD(numberOfWitnessSignatures);\n        require(valueInUSD <= limitInUSD, \"transfer-limit-exceeded\");\n\n        _storage.addSpending(valueInUSD);\n\n        emit Spent(valueInUSD, now);\n    }\n\n    function _addERC20Spending(\n        address token,\n        uint256 value,\n        uint256 numberOfWitnessSignatures\n    ) internal {\n        uint256 valueInUSD = _priceFeed().erc20PriceInUSD(token, value);\n        uint256 limitInUSD = _storage.transferCapacityInUSD(numberOfWitnessSignatures);\n        require(valueInUSD <= limitInUSD, \"transfer-limit-exceeded\");\n\n        _storage.addSpending(valueInUSD);\n\n        emit Spent(valueInUSD, now);\n    }\n\n    function _priceFeed() internal view returns (IPriceFeed) {\n        return IPriceFeed(resolveENS(keccak256(abi.encodePacked(\"price-feed-v0\"))));\n    }\n\n    function initialized() public override view returns (bool) {\n        return _initialized;\n    }\n\n    function label() public override view returns (bytes32) {\n        return _storage.label();\n    }\n\n    function nonce() public override view returns (uint256) {\n        return _storage.nonce();\n    }\n\n    function signingRequirements(bytes4 methodId)\n        public\n        override\n        view\n        returns (Storage.SigningRequirements memory)\n    {\n        return _storage.signingRequirements(methodId);\n    }\n\n    function securityPeriod(bytes4 methodId)\n        public\n        override\n        view\n        returns (Storage.SecurityPeriod memory)\n    {\n        return _storage.securityPeriod(methodId);\n    }\n\n    function lastExecutionTime(bytes4 selector) public override view returns (uint256) {\n        return _storage.lastExecutionTime(selector);\n    }\n\n    function resolveENS(bytes32 subdomain) public override view returns (address) {\n        address resolver = _ensGateway.resolverOfSubdomain(subdomain);\n        return Resolver(resolver).addr(_ensGateway.subdomainNode(subdomain));\n    }\n\n    /**\n     * @notice If the signature was signed by the owner it returns 0x1626ba7e, otherwise 0xffffffff\n     *\n     * bytes4(keccak256(\"isValidSignature(bytes32,bytes)\") = 0x1626ba7e\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        public\n        override\n        view\n        returns (bytes4)\n    {\n        if (_storage.isValidOwnerSignature(hash, signature)) {\n            return 0x1626ba7e;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    /**\n     * @notice Checks if the signature was signed by the owner\n     *\n     * @param hash hashed message of calling a method\n     * @param signature signed result of hash by the owner\n     */\n    function isValidOwnerSignature(bytes32 hash, bytes memory signature)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return _storage.isValidOwnerSignature(hash, signature);\n    }\n\n    /**\n     * @notice Checks if all signatures were signed by a subset of distinct witnesses\n     *\n     * @param hash hashed message of calling a method\n     * @param signatures signed results of hash by witnesses\n     */\n    function areValidWitnessSignatures(bytes32 hash, bytes[] memory signatures)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return _storage.areValidWitnessSignatures(hash, signatures);\n    }\n}\n"
    },
    "contracts/wallet/mixins/Executable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./BaseMixin.sol\";\nimport \"./interfaces/IExecutable.sol\";\nimport \"./interfaces/IAuthorizable.sol\";\n\nabstract contract Executable is BaseMixin, IExecutable {\n    using SafeERC20 for IERC20;\n\n    struct ERC20Approval {\n        address token;\n        address spender;\n    }\n    ERC20Approval[] internal _approvals;\n\n    function _initialize() internal virtual {\n        _storage.setSigningRequirements(this.execute.selector, true, 0);\n\n        bytes4[] memory dependencies = new bytes4[](2);\n        dependencies[0] = IAuthorizable.transferOwnership.selector;\n        _storage.setSecurityPeriod(this.execute.selector, 24 hours, dependencies);\n    }\n\n    /**\n     * @notice Executes arbitrary contract functions\n     * If 'ERC20.approve()'s were called in the batched executions,\n     * then all the amounts of the approved tokens need to be spent by the end of the call\n     *\n     * @param targets contract addresses to be executed for each execution\n     * @param values amount of ETH for each execution\n     * @param data methodID + args for each execution\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory data,\n        Storage.Signatures memory signatures\n    ) public override payable whenInitialized whenNotLocked returns (bytes[] memory) {\n        require(\n            targets.length == values.length && values.length == data.length,\n            \"different-params-length\"\n        );\n        _ensureSecurityPeriodPassed(this.execute.selector);\n        _ensureSignaturesValid(\n            this.execute.selector,\n            executeHash(targets, values, data),\n            signatures\n        );\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.execute.selector);\n\n        bytes[] memory returned = new bytes[](targets.length);\n        for (uint256 i = 0; i < targets.length; i++) {\n            returned[i] = _execute(targets[i], values[i], data[i], signatures);\n        }\n        _ensureApprovedERC20SpentAll();\n        return returned;\n    }\n\n    function _execute(\n        address target,\n        uint256 value,\n        bytes memory data,\n        Storage.Signatures memory signatures\n    ) internal nonReentrant returns (bytes memory) {\n        require(target != address(0), \"invalid-target\");\n        require(value <= address(this).balance, \"not-enough-balance\");\n\n        emit Executed(target, value, data);\n\n        if (value > 0) {\n            _addETHSpending(value, signatures.witnesses.length);\n        }\n        if (data.length > 0) {\n            (bytes4 methodId, bytes memory args) = abi.decode(data, (bytes4, bytes));\n            if (methodId == IERC20.transfer.selector) {\n                (address to, uint256 amount) = abi.decode(args, (address, uint256));\n                _addERC20Spending(target, amount, signatures.witnesses.length);\n                IERC20(target).safeTransfer(to, value);\n                return bytes(\"\");\n            } else if (methodId == IERC20.approve.selector) {\n                (address to, uint256 amount) = abi.decode(args, (address, uint256));\n                _addERC20Spending(target, amount, signatures.witnesses.length);\n                _addERC20Approval(target, to);\n                IERC20(target).approve(to, value);\n                return bytes(\"\");\n            } else {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, bytes memory returned) = target.call{value: value}(data);\n                if (success) {\n                    return returned;\n                } else {\n                    if (returned.length > 0) {\n                        assembly {\n                            let returned_size := mload(returned)\n                            revert(add(32, returned), returned_size)\n                        }\n                    } else {\n                        revert(\"external-call-failed\");\n                    }\n                }\n            }\n        } else {\n            _addETHSpending(value, signatures.witnesses.length);\n            payable(target).transfer(value);\n            return bytes(\"\");\n        }\n    }\n\n    function _addERC20Approval(address token, address spender) private {\n        if (spender == resolveENS(keccak256(abi.encodePacked(\"tx-relayer-v0\")))) {\n            return;\n        }\n        ERC20Approval storage approval = _approvals.push();\n        approval.token = token;\n        approval.spender = spender;\n    }\n\n    function _ensureApprovedERC20SpentAll() private {\n        for (uint256 i = 0; i < _approvals.length; i++) {\n            ERC20Approval storage approval = _approvals[i];\n            require(\n                IERC20(approval.token).allowance(address(this), approval.spender) == 0,\n                \"approved-erc20-not-spent\"\n            );\n        }\n        delete _approvals;\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'execute()'\n     */\n    function executeHash(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory data\n    ) public override view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.execute.selector,\n                    targets,\n                    values,\n                    abi.encode(data)\n                )\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/wallet/mixins/interfaces/IWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IAuthorizable.sol\";\nimport \"./IUpgradeable.sol\";\nimport \"./ILockable.sol\";\nimport \"./ITransferable.sol\";\nimport \"./IExecutable.sol\";\n\ninterface IWallet is IAuthorizable, IUpgradeable, ILockable, ITransferable, IExecutable {\n    function initialize(\n        address owner,\n        address[] calldata witnessAddrs,\n        bytes32[] calldata witnessNames\n    ) external;\n}\n"
    },
    "contracts/wallet/mixins/Lockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseMixin.sol\";\nimport \"./interfaces/ILockable.sol\";\n\nabstract contract Lockable is BaseMixin, ILockable {\n    function _initialize() internal virtual {\n        _storage.setSigningRequirements(this.lock.selector, false, 1);\n        _storage.setSigningRequirements(\n            this.unlock.selector,\n            false,\n            ((_storage.numberOfWitnesses() + 1) * 2) / 3\n        );\n\n        _storage.setSecurityPeriod(this.lock.selector, 0, new bytes4[](0));\n        bytes4[] memory dependencies = new bytes4[](1);\n        dependencies[0] = this.lock.selector;\n        _storage.setSecurityPeriod(this.unlock.selector, 24 hours, dependencies);\n    }\n\n    function locked() public override view returns (bool) {\n        return _storage.locked();\n    }\n\n    /**\n     * @notice Locks the wallet\n     *\n     * Signature of at least one of the witnesses required\n     */\n    function lock(Storage.Signatures memory signatures)\n        public\n        override\n        whenInitialized\n        whenNotLocked\n    {\n        _ensureSignaturesValid(this.lock.selector, lockHash(), signatures);\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.lock.selector);\n        _storage.setLocked(true);\n\n        emit Locked();\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'lock()'\n     */\n    function lockHash() public override view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.lock.selector\n                )\n            );\n    }\n\n    /**\n     * @notice Unlocks the wallet\n     *\n     * Signatures of '((n + 1) * 2) / 3' required where 'n' is the number of the witnesses\n     * Also, 24 hours needs to have passed after the lock has been called\n     */\n    function unlock(Storage.Signatures memory signatures)\n        public\n        override\n        whenInitialized\n        whenLocked\n    {\n        _ensureSecurityPeriodPassed(this.unlock.selector);\n        _ensureSignaturesValid(this.unlock.selector, unlockHash(), signatures);\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.unlock.selector);\n        _storage.setLocked(false);\n\n        emit Unlocked();\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'unlock()'\n     */\n    function unlockHash() public override view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.unlock.selector\n                )\n            );\n    }\n}\n"
    },
    "contracts/wallet/mixins/Transferable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./BaseMixin.sol\";\nimport \"./interfaces/ITransferable.sol\";\nimport \"./interfaces/IAuthorizable.sol\";\n\nabstract contract Transferable is BaseMixin, ITransferable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    function _initialize() internal virtual {\n        _storage.setSigningRequirements(this.transferETH.selector, true, 0);\n        _storage.setSigningRequirements(this.transferERC20.selector, true, 0);\n\n        bytes4[] memory dependencies = new bytes4[](1);\n        dependencies[0] = IAuthorizable.transferOwnership.selector;\n        _storage.setSecurityPeriod(this.transferETH.selector, 24 hours, dependencies);\n        _storage.setSecurityPeriod(this.transferERC20.selector, 24 hours, dependencies);\n    }\n\n    /**\n     * @notice How much an owner can spend with 0 witness\n     *\n     * For each signature of a witness is offered, limit is multiplied by 10\n     */\n    function minimumTransferLimitInUSD() public override view returns (uint256) {\n        return _storage.minimumTransferLimitInUSD();\n    }\n\n    function transferCapacityResetPeriod() public override view returns (uint256) {\n        return _storage.transferCapacityResetPeriod();\n    }\n\n    /**\n     * @notice Transfer capacity available in USD\n     *\n     * 10**18 = 1 USD\n     */\n    function transferCapacityInUSD(uint256 numberOfWitnessSignatures)\n        public\n        override\n        view\n        returns (uint256)\n    {\n        return _storage.transferCapacityInUSD(numberOfWitnessSignatures);\n    }\n\n    function cumulativeSpendingInUSD(uint256 fromTimestamp) public override view returns (uint256) {\n        return _storage.cumulativeSpendingInUSD(fromTimestamp);\n    }\n\n    /**\n     * @notice Transfers 'value' amount of ETH to 'to'\n     *\n     * @param to receiver address\n     * @param value amount of ETH\n     */\n    function transferETH(\n        address payable to,\n        uint256 value,\n        Storage.Signatures memory signatures\n    ) public override whenInitialized whenNotLocked {\n        require(value <= address(this).balance, \"not-enough-balance\");\n\n        _ensureSecurityPeriodPassed(this.transferETH.selector);\n        _ensureSignaturesValid(this.transferETH.selector, transferETHHash(to, value), signatures);\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.transferETH.selector);\n\n        _addETHSpending(value, signatures.witnesses.length);\n        to.transfer(value);\n\n        emit ETHTransferred(to, value);\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'transferETH()'\n     */\n    function transferETHHash(address payable to, uint256 value)\n        public\n        override\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.transferETH.selector,\n                    to,\n                    value\n                )\n            );\n    }\n\n    /**\n     * @notice Transfers 'value' amount of ERC20 'token' to 'to'\n     *\n     * @param token ERC20 address\n     * @param to receiver address\n     * @param value amount of ERC20\n     */\n    function transferERC20(\n        address token,\n        address to,\n        uint256 value,\n        Storage.Signatures memory signatures\n    ) public override whenInitialized whenNotLocked {\n        require(value <= IERC20(token).balanceOf(address(this)), \"not-enough-balance\");\n\n        _ensureSecurityPeriodPassed(this.transferERC20.selector);\n        _ensureSignaturesValid(\n            this.transferERC20.selector,\n            transferERC20Hash(token, to, value),\n            signatures\n        );\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.transferERC20.selector);\n\n        _addERC20Spending(token, value, signatures.witnesses.length);\n        IERC20(token).safeTransfer(to, value);\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'transferERC20()'\n     */\n    function transferERC20Hash(\n        address token,\n        address to,\n        uint256 value\n    ) public override view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.transferERC20.selector,\n                    token,\n                    to,\n                    value\n                )\n            );\n    }\n}\n"
    },
    "contracts/wallet/mixins/Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseMixin.sol\";\nimport \"./interfaces/IUpgradeable.sol\";\nimport \"../../core/interfaces/IWalletRegistry.sol\";\n\n/**\n * @notice Implements https://eips.ethereum.org/EIPS/eip-1822\n * EIP-1822: Universal Upgradeable Proxy Standard (UUPS)\n */\nabstract contract Upgradeable is BaseMixin, IUpgradeable {\n    // keccak256(\"PROXIABLE\") = 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\n    bytes32\n        private constant UUID = 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\n\n    function _initialize() internal virtual {\n        _storage.setSigningRequirements(this.upgrade.selector, true, 0);\n        _storage.setSecurityPeriod(this.upgrade.selector, 0, new bytes4[](0));\n    }\n\n    function proxiableUUID() public override pure returns (bytes32) {\n        return UUID;\n    }\n\n    function implementation() public override view returns (address addr) {\n        assembly {\n            addr := sload(UUID)\n        }\n    }\n\n    /**\n     * @notice Upgrades to a new implementation\n     *\n     * Signature of the owner required\n     */\n    function upgrade(address impl, Storage.Signatures memory signatures)\n        public\n        override\n        whenInitialized\n    {\n        _ensureSignaturesValid(this.upgrade.selector, upgradeHash(impl), signatures);\n\n        IWalletRegistry registry = IWalletRegistry(\n            resolveENS(keccak256(abi.encodePacked(\"wallet-registry-v0\")))\n        );\n        require(registry.queryWithAddress(impl) != bytes32(0), \"not-registered\");\n        require(UUID == Upgradeable(impl).proxiableUUID(), \"not-upgradeable\");\n\n        _storage.incrementNonce();\n        _storage.updateLastExecutionTime(this.upgrade.selector);\n\n        assembly {\n            sstore(UUID, impl)\n        }\n\n        emit Upgraded(impl);\n    }\n\n    /**\n     * @return a hash used to generate signature to properly call 'upgrade()'\n     */\n    function upgradeHash(address impl) public override view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    address(this),\n                    _storage.nonce(),\n                    this.upgrade.selector,\n                    impl\n                )\n            );\n    }\n}\n"
    },
    "contracts/wallet/Wallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./mixins/BaseMixin.sol\";\nimport \"./mixins/Authorizable.sol\";\nimport \"./mixins/Upgradeable.sol\";\nimport \"./mixins/Lockable.sol\";\nimport \"./mixins/Transferable.sol\";\nimport \"./mixins/Executable.sol\";\nimport \"./interfaces/IWallet.sol\";\nimport \"../core/interfaces/IENSGateway.sol\";\n\ncontract Wallet is\n    BaseMixin,\n    Authorizable,\n    Upgradeable,\n    Lockable,\n    Transferable,\n    Executable,\n    IWallet\n{\n    /**\n     * @notice Initializes the wallet\n     */\n    function initialize(\n        IENSGateway ensGateway,\n        bytes32 label,\n        address owner,\n        address[] memory witnessAddrs,\n        bytes32[] memory witnessNames\n    ) public override initializer {\n        _initialize(ensGateway, label);\n        require(witnessAddrs.length == witnessNames.length, \"different-param-lengths\");\n        require(witnessAddrs.length > 0, \"at-least-one-witness-required\");\n\n        _storage.transferOwnership(owner);\n        for (uint256 i = 0; i < witnessAddrs.length; i++) {\n            _storage.addWitness(witnessAddrs[i], witnessNames[i]);\n        }\n\n        _initialize();\n    }\n\n    function _initialize()\n        internal\n        override(Authorizable, Upgradeable, Lockable, Transferable, Executable)\n    {\n        Authorizable._initialize();\n        Upgradeable._initialize();\n        Lockable._initialize();\n        Transferable._initialize();\n        Executable._initialize();\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}